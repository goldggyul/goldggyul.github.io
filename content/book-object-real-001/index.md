---
emoji: 🐰
title: 01. 협력하는 객체들의 공동체 |📓 객체지향의 사실과 오해
date: '2022-10-06 00:41:00'
author: goldggyul
tags: 도서
categories: 도서
---

> 본 게시글은 [객체지향의 사실과 오해](http://www.yes24.com/Product/Goods/18249021) 책을 읽고 작성했습니다.

# 📓 객체지향의 사실과 오해 | 역할, 책임, 협력 관점에서 본 객체지향 

> 그래서 객체지향이 무엇인가?를 얘기하고자 하는 책인 듯하다.
>
> 저번 학기 객체지향개발방법론 수업을 들으면서, 교수님이 정말 정말 강조했던 내용이 있다.
>
> 객체지향의 핵심은 결국 객체이고, 시스템을 구성하는 오브젝트들의 커뮤니케이션(메세지 패싱, 콜라보레이션)을 통해 시스템이 제공해야할 서비스(시스템 오퍼레이션)을 제공하는 것이 객체지향 시스템이라고 하셨다.
>
> 즉, 객체들 간의 협력을 통해 시스템 오퍼레이션-서비스를 만들어내는 것이 객체지향 시스템이라는 말로 이해했다.
>
> 1장에서 하는 말은 교수님의 말과 결국 같은 말을 하고 있는 것 같다. (결국 배웠던 거지만 간과하고 있던 내용...)

# ☕️ 협력하는 객체들의 공동체

흔히 객체지향을 실세계의 모방이라는 개념으로 설명한다. 하지만 실제로는 새로운 세계를 만드는 것에 가깝다. 그럼에도 불구하고 계속해서 '실세계의 모방'으로 설명하는 이유는 실무적인 관점에서는 부적합하지만 '객체 지향'을 기본적으로 학습하기엔 효과적이기 때문이다. 따라서 기본적인 내용을 설명하기 위해 실세계 사물의 모방이라는 관점으로 객체지향의 다양한 개념을 살펴보자.

## 협력하는 사람들

카페에서 손님이 커피를 주문하고, 캐셔가 주문을 받고, 바리스타가 주문대로 커피를 만들면, 캐셔가 커피가 나왔다는 안내를 하고, 손님이 커피를 받아간다.

이게 모두 커피 주문이라는 `협력 관계`에 참여하는 사람들이 각자의 `역할`과 `책임`을 다하기 때문에 가능한 일이다.

### 요청과 응답으로 구성된 협력

사람들은 스스로 해결하지 못하는 문제와 마주치면 해결할 수 있는 사람에게 도움을 요청(request)한다. 그리고 또 그 사람은 다른 사람에게 요청하고, 또 반대 방향으로 응답이 연쇄적으로 일어난다.

### 역할과 책임

사람들은 `협력`을 위해 특정한 `역할`을 맡고, `역할`에 적합한 `책임`을 수행한다. 이것으로부터 중요한 개념을 알 수 있다.

- 여러 사람이 동일한 역할을 수행할 수 있다. 역할에 맡는 책임만 다한다면 사람이 달라져도 상관없다.
- 동일한 역할을 수행할 수 있다면 다른 사람이 일을 해도 상관없다.
- 책임을 수행하는 방법은 자율적으로 선택할 수 있다. 어떻게든 하기만 하면 된다. 동일한 요청을 받더라도 역할을 수행하는 사람마다 다른 방식(커피 주세요 -> 핸드드립, 커피 머신으로 내리기 등등..)으로 요청을 처리할 수 있다. 이처럼 동<u>**일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력**</u>을 `다형성`이라고 한다. 
- 한 사람이 동시에 여러 역할을 수행할 수 있다.

이 개념들이 객체에도 똑같이 적용된다.

## 👥 역할, 책임, 협력

사용자가 최종적으로 인식하게 되는 시스템의 기능은 객체<u>**들**</u>이 협력한 결과다. 결론적으로 시스템은 <u>**역할과 책임을 수행하는 객체**</u>로 분할되고, 시스템의 기능은 <u>**객체 간의 연쇄적인 요청/응답의 흐름**</u>으로 구성된 <u>**협력**</u>으로 구현된다.

객체지향 설계 시엔 객체에게 적절한 책임을 할당하는 것이 중요하다. 책임이 불분명한 객체는 애플리케이션의 미래 역시 불분명하게 만든다.

> SOLID 원칙 중에 단일 책임 원칙(SRP: 한 클래스는 하나의 책임만 가져야 한다)가 생각났다.

## 👤 협력 속에 사는 객체

과거의 전통적인 개발 방법은 데이터와 프로세스를 엄격하게 구분한다. 이반면 객체지향에서는 그 둘을 객체라는 하나의 틀 안에 묶어 놓으면서, 객체의 자율성을 보장한다.

- 객체 스스로 자신의 상태를 알고 어떤 행동을 할 수 있다는 것이다.

객체는 다른 객체와 협력하기 위해 메시지를 전송한다. 메세지를 받은 수신자는 미리 정해진 자신만의 방법인 `메서드(method)`를 통해 메세지를 처리한다. 그리고 객체지향 프로그래밍 언어에서 메서드는 클래스 안에 포함된 함수, 프로시저를 통해 구현된다.

메세지를 수신한 객체가 실행 시간에 메세지를 바탕으로 특정 메서드를 선택할 수 있다는 점은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분짓는 핵심적인 특징 중 하나이다. 바로 프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정하는 절차적인 언어와 확연히 구분되는 특징이다.

메세지와 메서드를 분리함으로써 객체들 간의 자율성이 증가한다. 메세지를 받고 객체가 판단해서 처리하는 메서드를 선택하는 것이다. 이게 자율성을 증가하는 핵심이고, <u>**캡슐화**</u>와도 깊은 관련이 있다.

> 인터페이스와 구현체를 말하는 걸까? 혹은 다형성 기반으로 런타임에 결정되는 메서드 호출?

## 🎥 객체지향의 본질

그래서 객체지향이 뭔데?

- 객체지향이란 시스템을 <u>**상호작용**</u>하는 `자율적인 객체`들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법.

  > 저번 학기 객체지향개발방법론 수업을 들으면서, 교수님이 정말 강조했던 내용이 있다.
  >
  > 객체지향의 핵심은 결국 객체이고,
  >
  > 시스템을 구성하는 오브젝트들의 커뮤니케이션(메세지 패싱, 콜라보레이션)을 통해 시스템이 제공해야할 서비스(시스템 오퍼레이션)을 제공하는 것이라고 하셨다.
  >
  > 즉 객체들 간의 협력을 통해 서비스를 제공하는 것이라는 의미이므로, 결국 비슷한 말을 하고 있는 것 같다.

- `자율적인 객체`란 상태와 행위(데이터와 프로세스)를 함께 지니고 스스로 자기 자신을 책임지는 객체를 의미
- 객체는 시스템의 행위-operation?-를 구현하기 위해 <u>**다른 객체와 협력**</u>한다. 각 객체는 <u>**협력 내에서 정해진 역할**</u>을 수행하고, 역할은 관련된 <u>**책임의 직합**</u>이다.
- 객체는 다른 객체에게 협력을 요청하면서 <u>**메세지를 전송**</u>하고, 메세지를 수신한 객체는 메세지 처리에 적합한 <u>**메서드를 자율적으로 선택**</u>한다.

### 객체를 지향해라. 클래스가 아니고.

많은 사람들은 객체지향 -> 클래스를 떠올린다. 대부분 클래스를 정의하는 방법과 클래스 사이 상속에 초점을 맞춘다. 또 대부분 UML의 대표적인 다이어그램으로 클래스 다이어그램을 뽑는다. 또한 객체지향 분석/설계의 목적을 훌륭한 클래스를 십결하는 것으로 배운다.

클래스가 객체지향 프로그래밍 언어의 관점에서 매우 중요한 구성요소인 것은 맞지만, 객체지향의 핵심을 이루는 중심 개념은 아니다. 자바스크립트 같은 프로토타입 기반 객체지향 언어에서는 <u>**클래스가 존재하지 않고 객체만이 존재**</u>한다. 또한 상속 역시 클래스가 아닌 객체 간의 위임(delegation) 메커니즘을 기반으로 한다.

> 나 조차 자바스크립트가 객체지향 언어라는 말을 들고, '클래스도 없는데 왜 객체지향이야?'라고 생각했었다. 나도 클래스를 중심으로 객체지향을 생각했던 듯...

지나치게 클래스를 강조하면 <u>**객체의 캡슐화를 저해하고 클래스를 서로 강하게 결합**</u>시킨다.

애플리케이션을 <u>**협력하는 객체들의 공동체**</u>가 아닌 <u>**클래스로 구성된 설계도**</u>로 보는 관점은 유연하고 확장 가능한 애플리케이션의 구축을 방해한다.

우선 '코드를 담는 클래스'에 집중하던 걸 '메세지를 주고받는 객체'의 관점으로 중심을 바꾸자. 중요한 건 어떤 클래스가 필요한 지가 아니고 어떤 객체들이 어떤 메세지를 주고받으며 협력하는가다. 클래스는 그리고 그런 협력 관계를 코드로 옮기는 도구일 뿐이다.

객체지향의 중심에는 클래스가 아니라 객체가 위치하며, 중요한 것은 클래스들의 정적인 관계가 아니라 메세지를 주고받는 객체들의 동적인 관계다.

> 역시 객체지향개발방법론 수업에서, OOAD에서는 시퀀스 다이어그램을 통해 클래스 다이어그램을 뽑아내는 것이지, 클래스를 먼저 생각하는 것이 아니라고 하셨다.
>
> 즉, 시퀀스 다이어그램 같은 dynamic model을 통해 그걸 모으면 static model인 클래스 다이어그램이 나오는 것이다.
>
> 시퀀스 다이어그램은 시스템을 구성하는 객체들의 커뮤니케이션이 나타난다. 즉 이 책에서 말하는 것과 같이 메세지를 주고받는 객체들의 동적인 관계가 객체지향의 중심인 것이다.

클래스의 구조와 메서드가 아닌 <u>**역할, 책임, 협력**</u>에 집중하자. 객체지향은 객체를 지향하는 것이지 <u>**클래스를 지향하는 것이 아니다.**</u>































```toc
```