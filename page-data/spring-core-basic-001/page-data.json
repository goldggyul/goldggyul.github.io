{"componentChunkName":"component---src-templates-blog-template-js","path":"/spring-core-basic-001/","result":{"data":{"cur":{"id":"96714aea-77d7-5225-96bf-abf1ec1c95b3","html":"<blockquote>\n<p>본 게시글은 <a href=\"https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8\">스프링 핵심 원리 - 기본편</a> 강의를 듣고 정리했습니다.</p>\n</blockquote>\n<h1 id=\"️-객체-지향-설계와-스프링\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\" aria-label=\"️ 객체 지향 설계와 스프링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>☘️ 객체 지향 설계와 스프링</h1>\n<p>스프링을 제대로 학습하려면 스프링이 제공하는 기능만 아는 게 아니라 객체지향의 원리와, 그 원리를 스프링이 어떻게 지원하는 지 함께 풀어가면서 이해해야 한다! 이 과정을 이해하고 나면 개발, 설계하는 시야가 달라지고 정말 재밌어진다.</p>\n<p>단순히 스프링 기능을 배우는 건 어렵지 않고, 스프링이 제공하는 핵심 가치와 원리를 제대로 파악하려면 객체 지향을 이해해야 한다. 스프링의 본질을 이해했다는 것은 객체 지향 설계의 본질을 이해하는 것과 같다.</p>\n<h2 id=\"-자바-진영의-추운-겨울과-스프링의-탄생\" style=\"position:relative;\"><a href=\"#-%EC%9E%90%EB%B0%94-%EC%A7%84%EC%98%81%EC%9D%98-%EC%B6%94%EC%9A%B4-%EA%B2%A8%EC%9A%B8%EA%B3%BC-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%ED%83%84%EC%83%9D\" aria-label=\" 자바 진영의 추운 겨울과 스프링의 탄생 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📌 자바 진영의 추운 겨울과 스프링의 탄생</h2>\n<p>당시 쓰던 EJB(Enterprise Java Bean)…</p>\n<p>하지만 여기서 불편함을 느끼고 <code class=\"language-text\">스프링</code>과 <code class=\"language-text\">하이버네이트</code> 두 기술이 개발되었다.</p>\n<p>스프링은 EJB 컨테이너, 하이버네이트는 EJB 엔티티빈 기술을 대체하게 되었다. 그리고 하이버네이트를 바탕으로 자바 ORM 표준으로 JPA가 나오게 되었다.</p>\n<p>EJB의 문제점을 지적하고, EJB 없이도 훌륭한 확장 가능한 애플리케이션이 개발할 수 있음을 코드로 보여주던 로드 존슨의 책에서 시작해서 스프링이 개발되게 되었다.</p>\n<p>스프링은 정말 좋지만 세팅이 힘들고, 스프링을 갖고 웹 애플리케이션을 개발하면, 톰캣이라는 웹서버에 앱을 war로 빌드해서 넣고 배포해야 하는데 이것도 복잡하다. 스프링부트에서는 당시 웹서버를 내장해서 편하게 띄우는 것이 유행하고 있어서 그를 받아들이고 설정도 거의 할 게 없도록 발전했다.</p>\n<h2 id=\"-스프링이란\" style=\"position:relative;\"><a href=\"#-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80\" aria-label=\" 스프링이란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📌 스프링이란?</h2>\n<h3 id=\"스프링-생태계\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-%EC%83%9D%ED%83%9C%EA%B3%84\" aria-label=\"스프링 생태계 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링 생태계</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 63.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB8ElEQVQ4y32TzWsTQRjG89958O7Ro3dBPAqCCnoRxZ5EPRRKhYjYgmhDVWhRbLW4JWm0ifnaJJtN9nsy2ZndmX1kJmaT1MQHQnjm4/d+zLuFtv8TNjHR9qugPIJSlmVrf4tatV+wSQfexIb6H/Pwv0Bk071EcMhMLgXIgbigdTAFUOpHDdx8dxkn/Y/al+1DHLRf5XcLs8NCpvOoGfK1KRA50PRquL5zCV/be9ofNt+gaDzSd5QK6/qybi2KItTbvzByhtpPCINjuxDpNKAu2aF9FMuPUR0e55CmV0GptgXCA+1nGZIkwKbxAGZU0/6o9x5va88Rp+M5cKf6FBtfbuDl6UPECdUbL77fxq3SFezXt7VX5SsF1MGd/Ws4Hxja71aeoWg8wSA058CmX8Hmj3v4bO7mGR5397B1eh+96Pffsqf9pWSCyKPw3QAsZnBHHlzHQ+CFkFJMgcp0ui1YfQuccQ0YEwrLspCwdKnkkDl4fbaRBxqQFlr+GZiYzDPknIPzBDGLIYRQ+SBJE70uxDLQDGu4++kqDOsALJ3gW6+ED41tjGhXv/Q/r7xKi6/MGEOjU0cYhrqv5cYJjPMjeOFoPjaLF1zXBSFk5ZDrTKXUI6LO2PYQMs0gEgkps9XAIAhAKV371cwmWLVDnb1YyR8rpeCysrDVjwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20221006150259795\"\n        title=\"image-20221006150259795\"\n        src=\"/static/524694aec4cd8d5b184031db0b6df34d/37523/image-20221006150259795.png\"\n        srcset=\"/static/524694aec4cd8d5b184031db0b6df34d/e9ff0/image-20221006150259795.png 180w,\n/static/524694aec4cd8d5b184031db0b6df34d/f21e7/image-20221006150259795.png 360w,\n/static/524694aec4cd8d5b184031db0b6df34d/37523/image-20221006150259795.png 720w,\n/static/524694aec4cd8d5b184031db0b6df34d/20c85/image-20221006150259795.png 999w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>스프링 프레임워크\n<ul>\n<li>핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트 등등</li>\n<li>최근엔 스프링 부트를 통해 스프링 프레임워크의 기술들을 편리하게 사용</li>\n</ul>\n</li>\n<li>스프링 부트\n<ul>\n<li>스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용</li>\n<li>톰캣 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않고도 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성</li>\n<li>필요한 라이브러리들을 다 가져오지 않아도 starter를 통해 필요한 나머지 라이브러리들도 다 받아올 수 있음</li>\n<li>외부 라이브러리 버전도 알아서 테스트해놓으므로 그냥 가져오면 됨</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"스프링-핵심-개념\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90\" aria-label=\"스프링 핵심 개념 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링 핵심 개념</h3>\n<p>핵심 컨셉을 이해해야 한다!</p>\n<p>스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크다. 따라서 스프링은 <u><strong>좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크</strong></u>다. 그렇다면 좋은 객체 지향 프로그래밍이란 뭔가?</p>\n<h2 id=\"-좋은-객체-지향-프로그래밍이란-\" style=\"position:relative;\"><a href=\"#-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-\" aria-label=\" 좋은 객체 지향 프로그래밍이란  permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📌 좋은 객체 지향 프로그래밍이란? ✨</h2>\n<h3 id=\"객체-지향-프로그래밍\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\" aria-label=\"객체 지향 프로그래밍 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체 지향 프로그래밍</h3>\n<ul>\n<li>객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러 개의 독립된 단위, 즉 <code class=\"language-text\">\"객체\"</code>들의 <code class=\"language-text\">모임</code>으로 파악하고자 하는 것이다. 각각의 <code class=\"language-text\">객체</code>는 <code class=\"language-text\">메시지</code> 를 주고받고, 데이터를 처리할 수 있다. (<code class=\"language-text\">협력</code>)</li>\n<li>객체 지향 프로그래밍은 프로그램을 <code class=\"language-text\">유연</code>하고 <code class=\"language-text\">변경</code>이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.\n<ul>\n<li>레고 블럭을 조립하듯이 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있다는 것</li>\n<li>바로 객체 지향의 핵심 <code class=\"language-text\">다형성</code>!</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"다형성\" style=\"position:relative;\"><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\" aria-label=\"다형성 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>다형성</h3>\n<blockquote>\n<p><u><strong>다형성이란 간단하게 말하면 하나의 타입에 여러 객체를 대입할 수 있는 성질</strong></u>이다.</p>\n<p>따라서 이 성질을 이용하면, 확장하거나 변경을 할 때 타입 변경 없이 쉽게할 수 있다.</p>\n</blockquote>\n<p>구현이 바뀌어도 역할만 같다면 해당 객체를 사용하는 데 문제가 없다!</p>\n<ul>\n<li>새로운 자동차가 나온다고 운전자를 바꿀 필요가 없다. 운전자는 그냥 운전할 수 있다.</li>\n</ul>\n<p>역할이라는 인터페이스를 따라서 구현을 해놨고, 사용자는 인터페이스에 대해서만 의존하면서 사용한다.</p>\n<p>다른 대상으로 변환이 가능하고, 심지어 완전 새로운 것이 나와도 기존 역할을 따르기만 한다면 사용할 수 있다. 세상을 바꾸지 않고 무한히 확장이 가능한 것.</p>\n<ul>\n<li>역할과 구현으로 세상을 구분했기 때문에 가능하다.</li>\n</ul>\n<h3 id=\"역할과-구현을-분리\" style=\"position:relative;\"><a href=\"#%EC%97%AD%ED%95%A0%EA%B3%BC-%EA%B5%AC%ED%98%84%EC%9D%84-%EB%B6%84%EB%A6%AC\" aria-label=\"역할과 구현을 분리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>역할과 구현을 분리</h3>\n<p>역할과 구현을 구분하면 세상이 단순해지고, 유연해지며 변경도 편리해진다.</p>\n<ul>\n<li>클라이언트는 대상의 역할(인터페이스)만 알면 된다.</li>\n<li>구현 대상의 내부 구조가 변경 되든 구현 대상이 바뀌든 클라이언트는 영향을 받지 않는다.</li>\n</ul>\n<p>프로그래밍 언어에서도 이런 개념을 차용한 것이다. 자바 언어의 측면에서 말하자면</p>\n<ul>\n<li>자바 언어의 다형성을 활용해서 해결\n<ul>\n<li>역할 == 인터페이스</li>\n<li>구현 == 인터페이스를 구현한 클래스, 구현 객체</li>\n</ul>\n</li>\n<li>객체를 설계할 때 역할과 구현을 명확히 분리한다.\n<ul>\n<li>객체 설계 시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기</li>\n<li>(물론 인터페이스가 아니라 그냥 일반 상속관계도 다형성이 가능하지만 인터페이스가 낫겠죠?)</li>\n</ul>\n</li>\n<li>그니까 핵심은 구현보다 역할이 더 중요하다는 것</li>\n</ul>\n<h3 id=\"객체는-협력이라는-관계부터-생각\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EB%8A%94-%ED%98%91%EB%A0%A5%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B4%80%EA%B3%84%EB%B6%80%ED%84%B0-%EC%83%9D%EA%B0%81\" aria-label=\"객체는 협력이라는 관계부터 생각 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체는 협력이라는 관계부터 생각</h3>\n<p>혼자 있는 객체는 없다. 생각해보면, 다형성을 공부하면서 뭐 클래스가 있고 부모를 상속받아 어쩌구… 하지만 이 관계에서 <u><strong>클라이언트</strong></u>가 없다. 중요한 건 클라이언트다.</p>\n<p>클라이언트가 요청을 하고, 서버가 응답한다. 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 522px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 95%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAATCAYAAACQjC21AAAACXBIWXMAAAsTAAALEwEAmpwYAAACXElEQVQ4y5VUy47TMBQ1nzAr/oAVbPgBNnwAX4BGYjG7ChDLSkiIx3KEEOyBBayAAdFFVaRhQCOxQIhh1EKr0kfSR5o2D5rYjhPnoGSaJk3TQVzJinN9fXyO770myFgYJt9w6ZNhGP8nQ0qZiZdr8QQ5SxaHFkUgQxSZ78zBpvoK6BpgBOQvAN4ej0FK77Hz8hvoHxP6dIqprmNmGBgOVHy4dAGVc1twlN7J3gzrFYYJYLVlgtyq4ua7X4AUcCkFpRTc82CZJg4uX0Tt/Fm4an8zYCI1CAIMVQVHrS76ioLA99ckmxMNg1ZzuS/cJDkB7PX6mEabVBWUsnTjIsaezzE1jDiL4WlJyS5s8ufn2VHIMB+U9xfNk5qL5uRfQTgFMCkZ6bnLe1wCRjUnAlnMQkpIIeJvetgJGP/6AkaJgB08SiWv3l1OspSFd8qpg7HFMXh9G3SHgFXKqwwrdQ2PP3dQlBamjfBz9x7MxjFsl0Ibj6HrOjj3wDlD49MbuHM7ZRjJ3SrXQLZfoXrUhWPNoE0m0McjzDwfh+UbeEYI9q9egeUJyExtRgT8AIs2zSTlyWEf1/casFwOX3hxV3icIwBg1X/ge2kb4481WJRiomkwDAMe92L5vVkHUgYpQ1VV0Gk2oLSbGA0Hy9OjIv/dbkM3LdQ7XbQVBY16HbZtw3EdUJPiwd59kGsEdyt3UkAhBCjj8fCEWAhB/FRF9xQxpY4DzhgYY7E/abjnX57iTIng4f7ualLyWdzUNUUxnWEnVrNSNvnO2NQ1+TjhC/S7/fg1Knxg/8fyKqLW+wuKXaqZMqSywQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20221006153615853\"\n        title=\"image-20221006153615853\"\n        src=\"/static/894da09a5e6884c4ac78e23be9122c70/29492/image-20221006153615853.png\"\n        srcset=\"/static/894da09a5e6884c4ac78e23be9122c70/e9ff0/image-20221006153615853.png 180w,\n/static/894da09a5e6884c4ac78e23be9122c70/f21e7/image-20221006153615853.png 360w,\n/static/894da09a5e6884c4ac78e23be9122c70/29492/image-20221006153615853.png 522w\"\n        sizes=\"(max-width: 522px) 100vw, 522px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h3 id=\"자바-언어의-다형성---code-classlanguage-text오버라이딩code\" style=\"position:relative;\"><a href=\"#%EC%9E%90%EB%B0%94-%EC%96%B8%EC%96%B4%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1---code-classlanguage-text%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9code\" aria-label=\"자바 언어의 다형성   code classlanguage text오버라이딩code permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>자바 언어의 다형성 - <code class=\"language-text\">오버라이딩</code>!</h3>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.44444444444444%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABS0lEQVQoz21RTUvDQBDNP/XmURR/hRdv4kk8KXoqRZAiClI9SKE9VEgDtrRJG6vmi3xsmmR298lumxDBBwMzw/DezBtDSok2pBCtnMBKjpnPdL89q3LGGKqqamoFgwsJoQsJyblufvcf4d11dD5YBNi7GiGJY8RxjDzPkTOGIAhgmiacpQOqqCE1akWxU4jLEm7vHt3TIzzZr7o3sx24q5WOIIrgRxFsewHLtOAsllqkIbwerTF2Y70hcY4g8MAF0Jn0cN4/04NEFYhIi4osBQ99CAnM3Tmmn9M/lhknDyaeJy5EkePH8xBFETY7xe3mW09rO1bdW7wd74M4cPlygcObA1BOSNJEmQaD5wlAFSoihGGovVGhzFZk6ow6FFiWwnwfYzAYYP21hvVhYTgcwvf97YZaHf+jJmkTqrM3RYEsy7QNZVEiTdPm279Y1BQiY/KXIgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20221006153906145\"\n        title=\"image-20221006153906145\"\n        src=\"/static/ad917838bdb352517a7a92ea1571a342/37523/image-20221006153906145.png\"\n        srcset=\"/static/ad917838bdb352517a7a92ea1571a342/e9ff0/image-20221006153906145.png 180w,\n/static/ad917838bdb352517a7a92ea1571a342/f21e7/image-20221006153906145.png 360w,\n/static/ad917838bdb352517a7a92ea1571a342/37523/image-20221006153906145.png 720w,\n/static/ad917838bdb352517a7a92ea1571a342/cf4cc/image-20221006153906145.png 1079w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>오버라이딩된 메서드가 실행된다.</p>\n</li>\n<li>\n<p><u><strong>다형성의 본질</strong></u>: 다형성으로 <u><strong>인터페이스를 구현한 객체를 실행 시점에 유연하게 변경</strong></u>할 수 있다.</p>\n<ul>\n<li>다형성의 본질을 이해하려 협력에서 시작해야 한다.</li>\n<li>클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.</li>\n</ul>\n</li>\n<li>\n<p>한계</p>\n<ul>\n<li>\n<p>대신 역할(인터페이스) 자체가 변하면 다 변경해야 한다!</p>\n<p>인터페이스를 안정적으로 변화가 없도록 잘 설계하는 것이 중요하다. 자바에서만 국한된 게 아니고, API 서버와 클라이언트 사이 인터페이스의 설계도 마찬가지다.</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"스프링과-객체-지향\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5\" aria-label=\"스프링과 객체 지향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링과 객체 지향</h3>\n<p>객체 지향의 꽃은 다형성이다. 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.</p>\n<p>스프링에서 이야기하는 <code class=\"language-text\">제어의 역전(IoC)</code>, <code class=\"language-text\">의존관계 주입(DI)</code>은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.</p>\n<h2 id=\"-solid-좋은-객체-지향-설계의-5가지-원칙\" style=\"position:relative;\"><a href=\"#-solid-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99\" aria-label=\" solid 좋은 객체 지향 설계의 5가지 원칙 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📌 SOLID: 좋은 객체 지향 설계의 5가지 원칙</h2>\n<p>사실 다형성 외에 SOLID라는 객체 지향 설계 원칙 역시 알아야 더 제대로 설명할 수가 있다.</p>\n<h3 id=\"1-code-classlanguage-textsrpcode-단일-책임-원칙single-responsibility-principle\" style=\"position:relative;\"><a href=\"#1-code-classlanguage-textsrpcode-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99single-responsibility-principle\" aria-label=\"1 code classlanguage textsrpcode 단일 책임 원칙single responsibility principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. <code class=\"language-text\">SRP</code>: 단일 책임 원칙(single responsibility principle)</h3>\n<p>사실 하나의 책임이라는 건 모호하다.</p>\n<p>그래서 중요한 기준으로 <code class=\"language-text\">변경</code>을 생각해볼 수 있다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것</p>\n<h3 id=\"2-code-classlanguage-textocpcode-개방-폐쇄-원칙-openclosed-principle\" style=\"position:relative;\"><a href=\"#2-code-classlanguage-textocpcode-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99-openclosed-principle\" aria-label=\"2 code classlanguage textocpcode 개방 폐쇄 원칙 openclosed principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>2. ✨<code class=\"language-text\">OCP</code>: 개방-폐쇄 원칙 (Open/closed principle)</h3>\n<p>소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다</p>\n<ul>\n<li>이게 어떻게 말이 돼? 확장을 하려면, 당연히 기존 코드를 변경해야 되지 않나?\n<ul>\n<li>다형성을 활용하면 된다! 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현하면 구현체를 바꾸면 된다.</li>\n</ul>\n</li>\n</ul>\n<p><u><strong>문제점</strong></u> ✨✨</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkElEQVQoz43Qy24SYRjG8bkJW6Vl5htgTqUKRaotw6kxYWECRozO2MwMG2Vnl4Tw0TVrboFbgkKnbriTv+GjNbrr4pf3kOfdvNqX3kfCfo/vX/uE1xFBeM23IORzv0+3232WT70enU6H2WyGJjIvcMURlm3jeEUsx6VgO+TMPHlhUTBt8qKAoecQ2WMsU6dgezjuicpa9t6rTIbhzx9oYRgSJwlRHBNF0V9xHJPEiRIr8eMuJkmS/wwGA4IgYD6fo23uVqTrFen9hvThN2n6wH2asl5vWK1Wz7ZcLtlut2gnToHyqUf59SnlyltK5TPelMoUi0Uc18F1HVUVZ8fFdfb9U/U8DyEEw+EQrXpWonFRxfd9Wu0rGs0Wfr3O5WWNht+i6beo1xrULnzenZ/jv6/SbLZpX31Q+WarrVQqFW5ufqFlXh6Q048RhoGZyyPMHEKYGIZA6HvGTlagZ7OI7BGGEJi7nGKqu8ODQ/VfbTweI6e3SCmZTCaK3JESKSf/kI+man7K7kynktFoxGKx4A97Q0IgjyuMSQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20221006155821285\"\n        title=\"image-20221006155821285\"\n        src=\"/static/3953abefa6843dc4f8f71e077f84fb4c/37523/image-20221006155821285.png\"\n        srcset=\"/static/3953abefa6843dc4f8f71e077f84fb4c/e9ff0/image-20221006155821285.png 180w,\n/static/3953abefa6843dc4f8f71e077f84fb4c/f21e7/image-20221006155821285.png 360w,\n/static/3953abefa6843dc4f8f71e077f84fb4c/37523/image-20221006155821285.png 720w,\n/static/3953abefa6843dc4f8f71e077f84fb4c/20751/image-20221006155821285.png 1037w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>구현체를 집어 넣는 코드는 변경해야 한다. 다형성을 사용했지만 OCP 원칙이 깨져버리는 것…</li>\n<li>따라서 <u><strong>객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다!!</strong></u> -> 스프링 컨테이너!</li>\n</ul>\n<h3 id=\"3-code-classlanguage-textlspcode-리스코프-치환-원칙-liskov-substitution-principle\" style=\"position:relative;\"><a href=\"#3-code-classlanguage-textlspcode-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99-liskov-substitution-principle\" aria-label=\"3 code classlanguage textlspcode 리스코프 치환 원칙 liskov substitution principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>3. <code class=\"language-text\">LSP</code>: 리스코프 치환 원칙 (Liskov substitution principle)</h3>\n<p>다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다. 단순히 컴파일이 되냐 안되냐의 문제가 아니고, 역할을 제대로 해야 한다.</p>\n<ul>\n<li>예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리 더라도 앞으로 가야함</li>\n</ul>\n<h3 id=\"4-code-classlanguage-textispcode-인터페이스-분리-원칙-interface-segregation-principle\" style=\"position:relative;\"><a href=\"#4-code-classlanguage-textispcode-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99-interface-segregation-principle\" aria-label=\"4 code classlanguage textispcode 인터페이스 분리 원칙 interface segregation principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>4. <code class=\"language-text\">ISP</code>: 인터페이스 분리 원칙 (Interface segregation principle)</h3>\n<p>특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.</p>\n<p>인터페이스가 변경되도 최대한 영향을 덜 줄 수 있다.</p>\n<ul>\n<li>자동차 인터페이스 ➡️ 운전 인터페이스, 정비 인터페이스로 분리</li>\n<li>사용자 클라이언트 ➡️ 운전자 클라이언트, 정비사 클라이언트로 분리</li>\n<li>분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음. 정비사 클라이언트만 바꾸면 된다.</li>\n<li>인터페이스가 명확해지고, 대체 가능성이 높아진다</li>\n</ul>\n<h3 id=\"5-code-classlanguage-textdipcode-의존관계-역전-원칙-dependency-inversion-principle\" style=\"position:relative;\"><a href=\"#5-code-classlanguage-textdipcode-%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99-dependency-inversion-principle\" aria-label=\"5 code classlanguage textdipcode 의존관계 역전 원칙 dependency inversion principle permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>5. ✨<code class=\"language-text\">DIP</code>: 의존관계 역전 원칙 (Dependency inversion principle)</h3>\n<p>구현 클래스에 의존하지 말고, 인터페이스에 의존해라. ➡️ 역할에 의존해라!</p>\n<ul>\n<li>그래야 언제든지 구현체를 갈아끼울 수 있겠죠?</li>\n</ul>\n<p><u><strong>문제점</strong></u> ✨✨</p>\n<p>위에 <a href=\"#2-code-classlanguage-textocpcode-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99-openclosed-principle\"><code class=\"language-text\">OCP</code> 원칙</a>에서 봤던 코드를 다시 봐보자.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 38.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkElEQVQoz43Qy24SYRjG8bkJW6Vl5htgTqUKRaotw6kxYWECRozO2MwMG2Vnl4Tw0TVrboFbgkKnbriTv+GjNbrr4pf3kOfdvNqX3kfCfo/vX/uE1xFBeM23IORzv0+3232WT70enU6H2WyGJjIvcMURlm3jeEUsx6VgO+TMPHlhUTBt8qKAoecQ2WMsU6dgezjuicpa9t6rTIbhzx9oYRgSJwlRHBNF0V9xHJPEiRIr8eMuJkmS/wwGA4IgYD6fo23uVqTrFen9hvThN2n6wH2asl5vWK1Wz7ZcLtlut2gnToHyqUf59SnlyltK5TPelMoUi0Uc18F1HVUVZ8fFdfb9U/U8DyEEw+EQrXpWonFRxfd9Wu0rGs0Wfr3O5WWNht+i6beo1xrULnzenZ/jv6/SbLZpX31Q+WarrVQqFW5ufqFlXh6Q048RhoGZyyPMHEKYGIZA6HvGTlagZ7OI7BGGEJi7nGKqu8ODQ/VfbTweI6e3SCmZTCaK3JESKSf/kI+man7K7kynktFoxGKx4A97Q0IgjyuMSQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"image-20221006155821285\"\n        title=\"image-20221006155821285\"\n        src=\"/static/3953abefa6843dc4f8f71e077f84fb4c/37523/image-20221006155821285.png\"\n        srcset=\"/static/3953abefa6843dc4f8f71e077f84fb4c/e9ff0/image-20221006155821285.png 180w,\n/static/3953abefa6843dc4f8f71e077f84fb4c/f21e7/image-20221006155821285.png 360w,\n/static/3953abefa6843dc4f8f71e077f84fb4c/37523/image-20221006155821285.png 720w,\n/static/3953abefa6843dc4f8f71e077f84fb4c/20751/image-20221006155821285.png 1037w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<ul>\n<li>\n<p>MemberService가 MemberRepository(인터페이스)라는 필드에 MemomryMemberRepository(구현체)를 할당하면서, 결국 MemomryMemberRepository를 의존하게 된다.</p>\n<ul>\n<li>의존한다 = 코드를 안다</li>\n<li>즉, MemberService는 인터페이스에 의존하지만, 구현 클래스도 동시에 의존한다</li>\n</ul>\n</li>\n<li>\n<p>MemberService가 구현체를 알고, 직접 선택(의존)하고 있기 때문에 변경하려면 코드를 바꿔야 한다.</p>\n<ul>\n<li><u><strong>DIP 위반!</strong></u></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"정리\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC\" aria-label=\"정리 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<p>분명 객체 지향의 핵심은 <u><strong>다형성</strong></u>이라고 했다. 근데 위 문제점들을 보면 OCP와 DIP를 위반한 것을 볼 수 있다. 다형성만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다. (클라이언트의 코드도 바꿔야 하기 때문)</p>\n<p>그럼 어떡해???? 뭔가 더 필요하다!</p>\n<h2 id=\"-객체-지향-설계와-스프링\" style=\"position:relative;\"><a href=\"#-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\" aria-label=\" 객체 지향 설계와 스프링 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📌 객체 지향 설계와 스프링</h2>\n<p>스프링 이야기에 왜 객체 지향 이야기가 나오는가?</p>\n<p>사실 스프링은 다음 기술을 통해 <u><strong>다형성 + OCP, DIP</strong></u>가 가능하게 지원해주는 기술이다.</p>\n<ul>\n<li>DI 컨테이너 제공 (DI(Dependency Injection): 의존관계, 의존성 주입): 자바 객체들을 컨테이너에 넣어 놓고 이 안에서 의존 관계를 연결하고 주입해준다.</li>\n</ul>\n<p>이 도움 덕에 클라이언트의 코드 변경 없이 쉽게 부품을 교체하듯이 기능을 확장할 수 있다.</p>\n<h3 id=\"스프링이-없으면\" style=\"position:relative;\"><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4-%EC%97%86%EC%9C%BC%EB%A9%B4\" aria-label=\"스프링이 없으면 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>스프링이 없으면..?</h3>\n<p>순수하게 자바로 OCP, DIP 원칙들을 지키면서 개발을 해보면, 결국 스프링 프레임워크를 만들게 된다. (더 정확히는 DI 컨테이너)</p>\n<ul>\n<li>DI 개념은 말로 설명해도 이해가 잘 안된다. 코드로 짜봐야 필요성을 알게된다! 그러면 앞으로 스프링이 왜? 만들어졌는지 코드로 이해해보자</li>\n</ul>\n<h3 id=\"정리-1\" style=\"position:relative;\"><a href=\"#%EC%A0%95%EB%A6%AC-1\" aria-label=\"정리 1 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>정리</h3>\n<p>모든 설계에 역할과 구현을 분리하자.</p>\n<ul>\n<li>이상적으로 ‘모든’ 설계지만.. 하지만 인터페이스를 무분별하게 남발하면 추상화라는 비용이 발생한다. -> 구현 클래스를 만드는 문제는 둘째치고, 개발자가 코드를 한 번 더 열어봐야 한다. 구현 클래스가 뭔지 안보이니까 더 살펴봐야 하는 것.</li>\n<li>그래서 추천하는 건.. 기능을 확장할 가능성이 없다면, 구체 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터 링해서 인터페이스를 도입하는 것도 방법이다.</li>\n<li>근데 딱 보고 확장 가능성이 있다면 도입하는 것이 좋다. 이런 미묘한 차이를 잘 설계하는 것이 좋은 설계..</li>\n</ul>\n<p>애플리케이션 설계도 공연을 설계 하듯이 배역만 만들어두고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계다.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#%EF%B8%8F-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\">☘️ 객체 지향 설계와 스프링</a></p>\n<ul>\n<li>\n<p><a href=\"#-%EC%9E%90%EB%B0%94-%EC%A7%84%EC%98%81%EC%9D%98-%EC%B6%94%EC%9A%B4-%EA%B2%A8%EC%9A%B8%EA%B3%BC-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%ED%83%84%EC%83%9D\">📌 자바 진영의 추운 겨울과 스프링의 탄생</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80\">📌 스프링이란?</a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-%EC%83%9D%ED%83%9C%EA%B3%84\">스프링 생태계</a></li>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90\">스프링 핵심 개념</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-\">📌 좋은 객체 지향 프로그래밍이란? ✨</a></p>\n<ul>\n<li><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\">객체 지향 프로그래밍</a></li>\n<li><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\">다형성</a></li>\n<li><a href=\"#%EC%97%AD%ED%95%A0%EA%B3%BC-%EA%B5%AC%ED%98%84%EC%9D%84-%EB%B6%84%EB%A6%AC\">역할과 구현을 분리</a></li>\n<li><a href=\"#%EA%B0%9D%EC%B2%B4%EB%8A%94-%ED%98%91%EB%A0%A5%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B4%80%EA%B3%84%EB%B6%80%ED%84%B0-%EC%83%9D%EA%B0%81\">객체는 협력이라는 관계부터 생각</a></li>\n<li><a href=\"#%EC%9E%90%EB%B0%94-%EC%96%B8%EC%96%B4%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1---%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9\">자바 언어의 다형성 - <code class=\"language-text\">오버라이딩</code>!</a></li>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5\">스프링과 객체 지향</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-solid-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99\">📌 SOLID: 좋은 객체 지향 설계의 5가지 원칙</a></p>\n<ul>\n<li><a href=\"#1-srp-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99single-responsibility-principle\">1. <code class=\"language-text\">SRP</code>: 단일 책임 원칙(single responsibility principle)</a></li>\n<li><a href=\"#2-ocp-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99-openclosed-principle\">2. ✨<code class=\"language-text\">OCP</code>: 개방-폐쇄 원칙 (Open/closed principle)</a></li>\n<li><a href=\"#3-lsp-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99-liskov-substitution-principle\">3. <code class=\"language-text\">LSP</code>: 리스코프 치환 원칙 (Liskov substitution principle)</a></li>\n<li><a href=\"#4-isp-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99-interface-segregation-principle\">4. <code class=\"language-text\">ISP</code>: 인터페이스 분리 원칙 (Interface segregation principle)</a></li>\n<li><a href=\"#5-dip-%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99-dependency-inversion-principle\">5. ✨<code class=\"language-text\">DIP</code>: 의존관계 역전 원칙 (Dependency inversion principle)</a></li>\n<li><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\">📌 객체 지향 설계와 스프링</a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4-%EC%97%86%EC%9C%BC%EB%A9%B4\">스프링이 없으면..?</a></li>\n<li><a href=\"#%EC%A0%95%EB%A6%AC-1\">정리</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","excerpt":"본 게시글은 스프링 핵심 원리 - 기본편 강의를 듣고 정리했습니다. ☘️ 객체 지향 설계와 스프링 스프링을 제대로 학습하려면 스프링이 제공하는 기능만 아는 게 아니라 객체지향의 원리와, 그 원리를 스프링이 어떻게 지원하는 지 함께 풀어가면서 이해해야 한다! 이 과정을 이해하고 나면 개발, 설계하는 시야가 달라지고 정말 재밌어진다. 단순히 스프링 기능을 배우는 건 어렵지 않고, 스프링이 제공하는 핵심 가치와 원리를 제대로 파악하려면 객체 지향을 이해해야 한다. 스프링의 본질을 이해했다는 것은 객체 지향 설계의 본질을 이해하는 것과 같다. 📌 자바 진영의 추운 겨울과 스프링의 탄생 당시 쓰던 EJB(Enterprise Java Bean)… 하지만 여기서 불편함을 느끼고 과  두 기술이 개발되었다. 스프링은 EJB 컨테이너, 하이버네이트는 EJB 엔티티빈 기술을 대체하게 되었다. 그리고 하이버네이트를 바탕으로 자바 ORM 표준으로 JPA가 나오게 되었다. EJB의 문제점을 지적하고, EJ…","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EF%B8%8F-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\">☘️ 객체 지향 설계와 스프링</a></p>\n<ul>\n<li>\n<p><a href=\"#-%EC%9E%90%EB%B0%94-%EC%A7%84%EC%98%81%EC%9D%98-%EC%B6%94%EC%9A%B4-%EA%B2%A8%EC%9A%B8%EA%B3%BC-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%98-%ED%83%84%EC%83%9D\">📌 자바 진영의 추운 겨울과 스프링의 탄생</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4%EB%9E%80\">📌 스프링이란?</a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-%EC%83%9D%ED%83%9C%EA%B3%84\">스프링 생태계</a></li>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EA%B0%9C%EB%85%90\">스프링 핵심 개념</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80-\">📌 좋은 객체 지향 프로그래밍이란? ✨</a></p>\n<ul>\n<li><a href=\"#%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D\">객체 지향 프로그래밍</a></li>\n<li><a href=\"#%EB%8B%A4%ED%98%95%EC%84%B1\">다형성</a></li>\n<li><a href=\"#%EC%97%AD%ED%95%A0%EA%B3%BC-%EA%B5%AC%ED%98%84%EC%9D%84-%EB%B6%84%EB%A6%AC\">역할과 구현을 분리</a></li>\n<li><a href=\"#%EA%B0%9D%EC%B2%B4%EB%8A%94-%ED%98%91%EB%A0%A5%EC%9D%B4%EB%9D%BC%EB%8A%94-%EA%B4%80%EA%B3%84%EB%B6%80%ED%84%B0-%EC%83%9D%EA%B0%81\">객체는 협력이라는 관계부터 생각</a></li>\n<li><a href=\"#%EC%9E%90%EB%B0%94-%EC%96%B8%EC%96%B4%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1---code-classlanguage-text%EC%98%A4%EB%B2%84%EB%9D%BC%EC%9D%B4%EB%94%A9code\">자바 언어의 다형성 - <code class=\"language-text\">오버라이딩</code>!</a></li>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5\">스프링과 객체 지향</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-solid-%EC%A2%8B%EC%9D%80-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%9D%98-5%EA%B0%80%EC%A7%80-%EC%9B%90%EC%B9%99\">📌 SOLID: 좋은 객체 지향 설계의 5가지 원칙</a></p>\n<ul>\n<li><a href=\"#1-code-classlanguage-textsrpcode-%EB%8B%A8%EC%9D%BC-%EC%B1%85%EC%9E%84-%EC%9B%90%EC%B9%99single-responsibility-principle\">1. <code class=\"language-text\">SRP</code>: 단일 책임 원칙(single responsibility principle)</a></li>\n<li><a href=\"#2-code-classlanguage-textocpcode-%EA%B0%9C%EB%B0%A9-%ED%8F%90%EC%87%84-%EC%9B%90%EC%B9%99-openclosed-principle\">2. ✨<code class=\"language-text\">OCP</code>: 개방-폐쇄 원칙 (Open/closed principle)</a></li>\n<li><a href=\"#3-code-classlanguage-textlspcode-%EB%A6%AC%EC%8A%A4%EC%BD%94%ED%94%84-%EC%B9%98%ED%99%98-%EC%9B%90%EC%B9%99-liskov-substitution-principle\">3. <code class=\"language-text\">LSP</code>: 리스코프 치환 원칙 (Liskov substitution principle)</a></li>\n<li><a href=\"#4-code-classlanguage-textispcode-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-%EB%B6%84%EB%A6%AC-%EC%9B%90%EC%B9%99-interface-segregation-principle\">4. <code class=\"language-text\">ISP</code>: 인터페이스 분리 원칙 (Interface segregation principle)</a></li>\n<li><a href=\"#5-code-classlanguage-textdipcode-%EC%9D%98%EC%A1%B4%EA%B4%80%EA%B3%84-%EC%97%AD%EC%A0%84-%EC%9B%90%EC%B9%99-dependency-inversion-principle\">5. ✨<code class=\"language-text\">DIP</code>: 의존관계 역전 원칙 (Dependency inversion principle)</a></li>\n<li><a href=\"#%EC%A0%95%EB%A6%AC\">정리</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EA%B0%9D%EC%B2%B4-%EC%A7%80%ED%96%A5-%EC%84%A4%EA%B3%84%EC%99%80-%EC%8A%A4%ED%94%84%EB%A7%81\">📌 객체 지향 설계와 스프링</a></p>\n<ul>\n<li><a href=\"#%EC%8A%A4%ED%94%84%EB%A7%81%EC%9D%B4-%EC%97%86%EC%9C%BC%EB%A9%B4\">스프링이 없으면..?</a></li>\n<li><a href=\"#%EC%A0%95%EB%A6%AC-1\">정리</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"date":"October 06, 2022","title":"객체 지향 설계와 스프링 - 스프링 핵심 원리 기본편 01 | 매일 1시간 👨🏻‍🏫 6일차","categories":"강의","author":"goldggyul","emoji":null,"imageEmoji":"spring-logo.png"},"fields":{"slug":"/spring-core-basic-001/"}},"next":{"id":"1274dea2-7096-557f-bcb5-a26a3fcd8a59","html":"<blockquote>\n<p>본 게시글은 <a href=\"http://www.yes24.com/Product/Goods/18249021\">객체지향의 사실과 오해</a> 책을 읽고 작성했습니다.</p>\n</blockquote>\n<h1 id=\"-객체지향의-사실과-오해--역할-책임-협력-관점에서-본-객체지향\" style=\"position:relative;\"><a href=\"#-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4--%EC%97%AD%ED%95%A0-%EC%B1%85%EC%9E%84-%ED%98%91%EB%A0%A5-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B8-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5\" aria-label=\" 객체지향의 사실과 오해  역할 책임 협력 관점에서 본 객체지향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📓 객체지향의 사실과 오해 | 역할, 책임, 협력 관점에서 본 객체지향</h1>\n<blockquote>\n<p>그래서 객체지향이 무엇인가?를 얘기하고자 하는 책인 듯하다.</p>\n<p>저번 학기 객체지향개발방법론 수업을 들으면서, 교수님이 정말 정말 강조했던 내용이 있다.</p>\n<p>객체지향의 핵심은 결국 객체이고, 시스템을 구성하는 오브젝트들의 커뮤니케이션(메세지 패싱, 콜라보레이션)을 통해 시스템이 제공해야할 서비스(시스템 오퍼레이션)을 제공하는 것이 객체지향 시스템이라고 하셨다.</p>\n<p>즉, 객체들 간의 협력을 통해 시스템 오퍼레이션-서비스를 만들어내는 것이 객체지향 시스템이라는 말로 이해했다.</p>\n<p>1장에서 하는 말은 교수님의 말과 결국 같은 말을 하고 있는 것 같다. (결국 배웠던 거지만 간과하고 있던 내용…)</p>\n</blockquote>\n<h1 id=\"️-협력하는-객체들의-공동체\" style=\"position:relative;\"><a href=\"#%EF%B8%8F-%ED%98%91%EB%A0%A5%ED%95%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EA%B3%B5%EB%8F%99%EC%B2%B4\" aria-label=\"️ 협력하는 객체들의 공동체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>☕️ 협력하는 객체들의 공동체</h1>\n<p>흔히 객체지향을 실세계의 모방이라는 개념으로 설명한다. 하지만 실제로는 새로운 세계를 만드는 것에 가깝다. 그럼에도 불구하고 계속해서 ‘실세계의 모방’으로 설명하는 이유는 실무적인 관점에서는 부적합하지만 ‘객체 지향’을 기본적으로 학습하기엔 효과적이기 때문이다. 따라서 기본적인 내용을 설명하기 위해 실세계 사물의 모방이라는 관점으로 객체지향의 다양한 개념을 살펴보자.</p>\n<h2 id=\"협력하는-사람들\" style=\"position:relative;\"><a href=\"#%ED%98%91%EB%A0%A5%ED%95%98%EB%8A%94-%EC%82%AC%EB%9E%8C%EB%93%A4\" aria-label=\"협력하는 사람들 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>협력하는 사람들</h2>\n<p>카페에서 손님이 커피를 주문하고, 캐셔가 주문을 받고, 바리스타가 주문대로 커피를 만들면, 캐셔가 커피가 나왔다는 안내를 하고, 손님이 커피를 받아간다.</p>\n<p>이게 모두 커피 주문이라는 <code class=\"language-text\">협력 관계</code>에 참여하는 사람들이 각자의 <code class=\"language-text\">역할</code>과 <code class=\"language-text\">책임</code>을 다하기 때문에 가능한 일이다.</p>\n<h3 id=\"요청과-응답으로-구성된-협력\" style=\"position:relative;\"><a href=\"#%EC%9A%94%EC%B2%AD%EA%B3%BC-%EC%9D%91%EB%8B%B5%EC%9C%BC%EB%A1%9C-%EA%B5%AC%EC%84%B1%EB%90%9C-%ED%98%91%EB%A0%A5\" aria-label=\"요청과 응답으로 구성된 협력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>요청과 응답으로 구성된 협력</h3>\n<p>사람들은 스스로 해결하지 못하는 문제와 마주치면 해결할 수 있는 사람에게 도움을 요청(request)한다. 그리고 또 그 사람은 다른 사람에게 요청하고, 또 반대 방향으로 응답이 연쇄적으로 일어난다.</p>\n<h3 id=\"역할과-책임\" style=\"position:relative;\"><a href=\"#%EC%97%AD%ED%95%A0%EA%B3%BC-%EC%B1%85%EC%9E%84\" aria-label=\"역할과 책임 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>역할과 책임</h3>\n<p>사람들은 <code class=\"language-text\">협력</code>을 위해 특정한 <code class=\"language-text\">역할</code>을 맡고, <code class=\"language-text\">역할</code>에 적합한 <code class=\"language-text\">책임</code>을 수행한다. 이것으로부터 중요한 개념을 알 수 있다.</p>\n<ul>\n<li>여러 사람이 동일한 역할을 수행할 수 있다. 역할에 맡는 책임만 다한다면 사람이 달라져도 상관없다.</li>\n<li>동일한 역할을 수행할 수 있다면 다른 사람이 일을 해도 상관없다.</li>\n<li>책임을 수행하는 방법은 자율적으로 선택할 수 있다. 어떻게든 하기만 하면 된다. 동일한 요청을 받더라도 역할을 수행하는 사람마다 다른 방식(커피 주세요 -> 핸드드립, 커피 머신으로 내리기 등등..)으로 요청을 처리할 수 있다. 이처럼 동<u><strong>일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력</strong></u>을 <code class=\"language-text\">다형성</code>이라고 한다.</li>\n<li>한 사람이 동시에 여러 역할을 수행할 수 있다.</li>\n</ul>\n<p>이 개념들이 객체에도 똑같이 적용된다.</p>\n<h2 id=\"-역할-책임-협력\" style=\"position:relative;\"><a href=\"#-%EC%97%AD%ED%95%A0-%EC%B1%85%EC%9E%84-%ED%98%91%EB%A0%A5\" aria-label=\" 역할 책임 협력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👥 역할, 책임, 협력</h2>\n<p>사용자가 최종적으로 인식하게 되는 시스템의 기능은 객체<u><strong>들</strong></u>이 협력한 결과다. 결론적으로 시스템은 <u><strong>역할과 책임을 수행하는 객체</strong></u>로 분할되고, 시스템의 기능은 <u><strong>객체 간의 연쇄적인 요청/응답의 흐름</strong></u>으로 구성된 <u><strong>협력</strong></u>으로 구현된다.</p>\n<p>객체지향 설계 시엔 객체에게 적절한 책임을 할당하는 것이 중요하다. 책임이 불분명한 객체는 애플리케이션의 미래 역시 불분명하게 만든다.</p>\n<blockquote>\n<p>SOLID 원칙 중에 단일 책임 원칙(SRP: 한 클래스는 하나의 책임만 가져야 한다)가 생각났다.</p>\n</blockquote>\n<h2 id=\"-협력-속에-사는-객체\" style=\"position:relative;\"><a href=\"#-%ED%98%91%EB%A0%A5-%EC%86%8D%EC%97%90-%EC%82%AC%EB%8A%94-%EA%B0%9D%EC%B2%B4\" aria-label=\" 협력 속에 사는 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>👤 협력 속에 사는 객체</h2>\n<p>과거의 전통적인 개발 방법은 데이터와 프로세스를 엄격하게 구분한다. 이반면 객체지향에서는 그 둘을 객체라는 하나의 틀 안에 묶어 놓으면서, 객체의 자율성을 보장한다.</p>\n<ul>\n<li>객체 스스로 자신의 상태를 알고 어떤 행동을 할 수 있다는 것이다.</li>\n</ul>\n<p>객체는 다른 객체와 협력하기 위해 메시지를 전송한다. 메세지를 받은 수신자는 미리 정해진 자신만의 방법인 <code class=\"language-text\">메서드(method)</code>를 통해 메세지를 처리한다. 그리고 객체지향 프로그래밍 언어에서 메서드는 클래스 안에 포함된 함수, 프로시저를 통해 구현된다.</p>\n<p>메세지를 수신한 객체가 실행 시간에 메세지를 바탕으로 특정 메서드를 선택할 수 있다는 점은 다른 프로그래밍 언어와 객체지향 프로그래밍 언어를 구분짓는 핵심적인 특징 중 하나이다. 바로 프로시저 호출에 대한 실행 코드를 컴파일 시간에 결정하는 절차적인 언어와 확연히 구분되는 특징이다.</p>\n<p>메세지와 메서드를 분리함으로써 객체들 간의 자율성이 증가한다. 메세지를 받고 객체가 판단해서 처리하는 메서드를 선택하는 것이다. 이게 자율성을 증가하는 핵심이고, <u><strong>캡슐화</strong></u>와도 깊은 관련이 있다.</p>\n<blockquote>\n<p>인터페이스와 구현체를 말하는 걸까? 혹은 다형성 기반으로 런타임에 결정되는 메서드 호출?</p>\n</blockquote>\n<h2 id=\"-객체지향의-본질\" style=\"position:relative;\"><a href=\"#-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EB%B3%B8%EC%A7%88\" aria-label=\" 객체지향의 본질 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>🎥 객체지향의 본질</h2>\n<p>그래서 객체지향이 뭔데?</p>\n<ul>\n<li>\n<p>객체지향이란 시스템을 <u><strong>상호작용</strong></u>하는 <code class=\"language-text\">자율적인 객체</code>들의 공동체로 바라보고 객체를 이용해 시스템을 분할하는 방법.</p>\n<blockquote>\n<p>저번 학기 객체지향개발방법론 수업을 들으면서, 교수님이 정말 강조했던 내용이 있다.</p>\n<p>객체지향의 핵심은 결국 객체이고,</p>\n<p>시스템을 구성하는 오브젝트들의 커뮤니케이션(메세지 패싱, 콜라보레이션)을 통해 시스템이 제공해야할 서비스(시스템 오퍼레이션)을 제공하는 것이라고 하셨다.</p>\n<p>즉 객체들 간의 협력을 통해 서비스를 제공하는 것이라는 의미이므로, 결국 비슷한 말을 하고 있는 것 같다.</p>\n</blockquote>\n</li>\n<li>\n<p><code class=\"language-text\">자율적인 객체</code>란 상태와 행위(데이터와 프로세스)를 함께 지니고 스스로 자기 자신을 책임지는 객체를 의미</p>\n</li>\n<li>\n<p>객체는 시스템의 행위-operation?-를 구현하기 위해 <u><strong>다른 객체와 협력</strong></u>한다. 각 객체는 <u><strong>협력 내에서 정해진 역할</strong></u>을 수행하고, 역할은 관련된 <u><strong>책임의 직합</strong></u>이다.</p>\n</li>\n<li>\n<p>객체는 다른 객체에게 협력을 요청하면서 <u><strong>메세지를 전송</strong></u>하고, 메세지를 수신한 객체는 메세지 처리에 적합한 <u><strong>메서드를 자율적으로 선택</strong></u>한다.</p>\n</li>\n</ul>\n<h3 id=\"객체를-지향해라-클래스가-아니고\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%A7%80%ED%96%A5%ED%95%B4%EB%9D%BC-%ED%81%B4%EB%9E%98%EC%8A%A4%EA%B0%80-%EC%95%84%EB%8B%88%EA%B3%A0\" aria-label=\"객체를 지향해라 클래스가 아니고 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체를 지향해라. 클래스가 아니고.</h3>\n<p>많은 사람들은 객체지향 -> 클래스를 떠올린다. 대부분 클래스를 정의하는 방법과 클래스 사이 상속에 초점을 맞춘다. 또 대부분 UML의 대표적인 다이어그램으로 클래스 다이어그램을 뽑는다. 또한 객체지향 분석/설계의 목적을 훌륭한 클래스를 십결하는 것으로 배운다.</p>\n<p>클래스가 객체지향 프로그래밍 언어의 관점에서 매우 중요한 구성요소인 것은 맞지만, 객체지향의 핵심을 이루는 중심 개념은 아니다. 자바스크립트 같은 프로토타입 기반 객체지향 언어에서는 <u><strong>클래스가 존재하지 않고 객체만이 존재</strong></u>한다. 또한 상속 역시 클래스가 아닌 객체 간의 위임(delegation) 메커니즘을 기반으로 한다.</p>\n<blockquote>\n<p>나 조차 자바스크립트가 객체지향 언어라는 말을 들고, ‘클래스도 없는데 왜 객체지향이야?‘라고 생각했었다. 나도 클래스를 중심으로 객체지향을 생각했던 듯…</p>\n</blockquote>\n<p>지나치게 클래스를 강조하면 <u><strong>객체의 캡슐화를 저해하고 클래스를 서로 강하게 결합</strong></u>시킨다.</p>\n<p>애플리케이션을 <u><strong>협력하는 객체들의 공동체</strong></u>가 아닌 <u><strong>클래스로 구성된 설계도</strong></u>로 보는 관점은 유연하고 확장 가능한 애플리케이션의 구축을 방해한다.</p>\n<p>우선 ‘코드를 담는 클래스’에 집중하던 걸 ‘메세지를 주고받는 객체’의 관점으로 중심을 바꾸자. 중요한 건 어떤 클래스가 필요한 지가 아니고 어떤 객체들이 어떤 메세지를 주고받으며 협력하는가다. 클래스는 그리고 그런 협력 관계를 코드로 옮기는 도구일 뿐이다.</p>\n<p>객체지향의 중심에는 클래스가 아니라 객체가 위치하며, 중요한 것은 클래스들의 정적인 관계가 아니라 메세지를 주고받는 객체들의 동적인 관계다.</p>\n<blockquote>\n<p>역시 객체지향개발방법론 수업에서, OOAD에서는 시퀀스 다이어그램을 통해 클래스 다이어그램을 뽑아내는 것이지, 클래스를 먼저 생각하는 것이 아니라고 하셨다.</p>\n<p>즉, 시퀀스 다이어그램 같은 dynamic model을 통해 그걸 모으면 static model인 클래스 다이어그램이 나오는 것이다.</p>\n<p>시퀀스 다이어그램은 시스템을 구성하는 객체들의 커뮤니케이션이 나타난다. 즉 이 책에서 말하는 것과 같이 메세지를 주고받는 객체들의 동적인 관계가 객체지향의 중심인 것이다.</p>\n</blockquote>\n<p>클래스의 구조와 메서드가 아닌 <u><strong>역할, 책임, 협력</strong></u>에 집중하자. 객체지향은 객체를 지향하는 것이지 <u><strong>클래스를 지향하는 것이 아니다.</strong></u></p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4--%EC%97%AD%ED%95%A0-%EC%B1%85%EC%9E%84-%ED%98%91%EB%A0%A5-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B8-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5\">📓 객체지향의 사실과 오해 | 역할, 책임, 협력 관점에서 본 객체지향</a></p>\n</li>\n<li>\n<p><a href=\"#%EF%B8%8F-%ED%98%91%EB%A0%A5%ED%95%98%EB%8A%94-%EA%B0%9D%EC%B2%B4%EB%93%A4%EC%9D%98-%EA%B3%B5%EB%8F%99%EC%B2%B4\">☕️ 협력하는 객체들의 공동체</a></p>\n<ul>\n<li>\n<p><a href=\"#%ED%98%91%EB%A0%A5%ED%95%98%EB%8A%94-%EC%82%AC%EB%9E%8C%EB%93%A4\">협력하는 사람들</a></p>\n<ul>\n<li><a href=\"#%EC%9A%94%EC%B2%AD%EA%B3%BC-%EC%9D%91%EB%8B%B5%EC%9C%BC%EB%A1%9C-%EA%B5%AC%EC%84%B1%EB%90%9C-%ED%98%91%EB%A0%A5\">요청과 응답으로 구성된 협력</a></li>\n<li><a href=\"#%EC%97%AD%ED%95%A0%EA%B3%BC-%EC%B1%85%EC%9E%84\">역할과 책임</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#-%EC%97%AD%ED%95%A0-%EC%B1%85%EC%9E%84-%ED%98%91%EB%A0%A5\">👥 역할, 책임, 협력</a></p>\n</li>\n<li>\n<p><a href=\"#-%ED%98%91%EB%A0%A5-%EC%86%8D%EC%97%90-%EC%82%AC%EB%8A%94-%EA%B0%9D%EC%B2%B4\">👤 협력 속에 사는 객체</a></p>\n</li>\n<li>\n<p><a href=\"#-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EB%B3%B8%EC%A7%88\">🎥 객체지향의 본질</a></p>\n<ul>\n<li><a href=\"#%EA%B0%9D%EC%B2%B4%EB%A5%BC-%EC%A7%80%ED%96%A5%ED%95%B4%EB%9D%BC-%ED%81%B4%EB%9E%98%EC%8A%A4%EA%B0%80-%EC%95%84%EB%8B%88%EA%B3%A0\">객체를 지향해라. 클래스가 아니고.</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 06, 2022","title":"01. 협력하는 객체들의 공동체 |📓 객체지향의 사실과 오해","categories":"도서","author":"goldggyul","emoji":null,"imageEmoji":"working.png"},"fields":{"slug":"/book-object-real-001/"}},"prev":{"id":"fed3c6da-efb4-546f-afde-18ce4697ef9e","html":"<blockquote>\n<p>본 게시글은 <a href=\"http://www.yes24.com/Product/Goods/18249021\">객체지향의 사실과 오해</a> 책을 읽고 작성했습니다.</p>\n</blockquote>\n<h1 id=\"-객체지향의-사실과-오해--역할-책임-협력-관점에서-본-객체지향\" style=\"position:relative;\"><a href=\"#-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4--%EC%97%AD%ED%95%A0-%EC%B1%85%EC%9E%84-%ED%98%91%EB%A0%A5-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B8-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5\" aria-label=\" 객체지향의 사실과 오해  역할 책임 협력 관점에서 본 객체지향 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>📓 객체지향의 사실과 오해 | 역할, 책임, 협력 관점에서 본 객체지향</h1>\n<p>세 줄 요약</p>\n<ol>\n<li>객체는 <u><strong>협력하기 위한 존재</strong></u>이므로, 협력에 참여할 수 있는 <u><strong>유일한 방법인 행동</strong></u>에 초점을 맞춰라. 그 이후에 필요한 <u><strong>상태</strong></u>를 선택하게 되는 것이다.</li>\n<li>객체는 협력 속에서 메세지를 통해 행동이 유발되지만, 객체의 상태가 변경될 지 아닐 지는 <u><strong>객체 스스로 결정</strong></u>한다.</li>\n<li>객체가 <u><strong>상태를 숨기고</strong></u> 행동을 경계로 <u><strong>캡슐화</strong></u>함으로써 <u><strong>객체의 자율성</strong></u>이 높아지고 협력을 단순하고 유연하게 만들 수 있다.</li>\n</ol>\n<h1 id=\"-이상한-나라의-객체\" style=\"position:relative;\"><a href=\"#-%EC%9D%B4%EC%83%81%ED%95%9C-%EB%82%98%EB%9D%BC%EC%9D%98-%EA%B0%9D%EC%B2%B4\" aria-label=\" 이상한 나라의 객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>😼 이상한 나라의 객체</h1>\n<h2 id=\"객체\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4\" aria-label=\"객체 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체</h2>\n<ul>\n<li>\n<h3 id=\"객체지향과-인지-능력\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EA%B3%BC-%EC%9D%B8%EC%A7%80-%EB%8A%A5%EB%A0%A5\" aria-label=\"객체지향과 인지 능력 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체지향과 인지 능력</h3>\n</li>\n</ul>\n<p>객체지향 패러다임은 인간이 인지할 수 있는 다양한 객체들이 모여 현실 세계를 이루는 것처럼, 소프트웨어의 세계 역시 인간이 인지할 수 있는 다양한 <u><strong>소프트웨어 객체들이 모여 이루어져 있다</strong></u>는 믿음에서 출발한다. 현실세계와 소프트웨어 세계 사이의 유사성은 여기까지고, 객체지향 패러다임의 목적은 현실 세계와 소프트웨어 세계의 1:1 모방이 아닌, <u><strong>현실 세계를 기반으로 새로운 세계를 창조</strong></u>하는 것이다.</p>\n<ul>\n<li>\n<h3 id=\"상태-행동-식별자\" style=\"position:relative;\"><a href=\"#%EC%83%81%ED%83%9C-%ED%96%89%EB%8F%99-%EC%8B%9D%EB%B3%84%EC%9E%90\" aria-label=\"상태 행동 식별자 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상태, 행동, 식별자</h3>\n</li>\n</ul>\n<p><u><strong>상태는 행동의 결과</strong></u>다. 객체의 상태는 객체에 존재하는 정적인 프로퍼티와 동적인 프로퍼티 값으로 구성된다. 객체의 프로퍼티는 단순한 값(숫자, 문자열, 참/거짓 등등)과 다른 객체를 참조하는 링크로 구분할 수 있다.</p>\n<ul>\n<li>\n<h3 id=\"객체는-자율적인-존재\" style=\"position:relative;\"><a href=\"#%EA%B0%9D%EC%B2%B4%EB%8A%94-%EC%9E%90%EC%9C%A8%EC%A0%81%EC%9D%B8-%EC%A1%B4%EC%9E%AC\" aria-label=\"객체는 자율적인 존재 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>객체는 자율적인 존재</h3>\n</li>\n</ul>\n<p>객체는 자율적인 존재다. 자율적인 <u><strong>객체는 스스로 자신의 상태를 책임</strong></u>져야 한다. 외부의 객체가 객체의 상태를 간접적으로 변경하거나 조회하기 위해선 행동을 이용한다. 객체지향의 기본 사상은 <u><strong>상태/(상태를 조작하기 위한) 행동을 하나의 단위로 묶는 것</strong></u>이다.</p>\n<p>객체는 혼자 있지 않는다. 객체는 다른 객체와 상호작용하며 협력하는 공동체에 참여한다. 객체가 다른 객체와 협력하는 유일한 방법은 다른 객체에게 메세지를 보내는 것 뿐이다. 이런 메세지를 통해 객체의 행동이 유발되지만, 진짜 객체의 상태를 변경할지 말지는 객체 스스로 결정한다.</p>\n<p>상태를 외부에 노출시키지 않고 행동을 경계로 <code class=\"language-text\">캡슐화</code>함으로써 객체의 자율성을 높일 수 있다. 캡슐화를 통해 객체의 자율성을 높이고 협력을 단순하고 유연하게 만들 수 있다.</p>\n<h2 id=\"-행동이-상태를-결정한다\" style=\"position:relative;\"><a href=\"#-%ED%96%89%EB%8F%99%EC%9D%B4-%EC%83%81%ED%83%9C%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%9C%EB%8B%A4\" aria-label=\" 행동이 상태를 결정한다 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>✨ 행동이 상태를 결정한다</h2>\n<p>객체지향에서 쉽게 빠지는 함정은 <u><strong>상태를 중심으로 객체를 바라보는 것</strong></u>이다. 초보자들은 먼저 객체에 필요한 상태가 무엇인지를 결정하고, 그 상태에 필요한 행동을 결정한다.</p>\n<ul>\n<li>앨리스 객체를 설계할 때, 초보자들은 앨리스 객체에계 필요한 상태로 키와 위치를 추가한 후에야 키와 위치를 변경하거나 조회할 수 있는 행동이 무엇인지를 고민한다.</li>\n</ul>\n<p>하지만 <u><strong>상태를 먼저 결정하고 행동을 나중에 결정하는 방법은 설계에 나쁜 영향을 끼친다.</strong></u></p>\n<ol>\n<li>캡슐화가 저해된다. 상태에 초점을 맞출 경우 상태가 객체 내부로 깔끔하게 캡슐화되지 못하고 공용 인터페이스에 그대로 노출되어버릴 확률이 높아진다.</li>\n<li>객체를 협력자가 아닌 고립된 섬으로 만든다. 객체가 필요한 이유는 다른 객체와 협력하기 위해서인데, 상태를 먼저 고려할 경우 협력에서 벗어나 객체를 설계하게 함으로써 협력에 적합하지 못한 객체를 창조하게 된다.</li>\n<li>객체의 재사용성이 저하된다. 객체의 재사용성은 다양한 협력에 참여할 수 있는 능력에서 나오는데, 상태에 초점을 맞춘다면 그게 어렵다.</li>\n</ol>\n<p>객체 시민의 덕목은 상태가 아니라 행동에 초점을 맞추는 것이다. 객체는 다른 객체와 협력하기 위해 존재하고, 객체의 행동은 객체가 협력에 참여하는 유일한 방법이기 때문이다.</p>\n<br/>\n<p>객체지향 설계에선 애플리케이션에 필요한 <u><strong>협력</strong></u>을 생각하고, 협력에 참여하는 데 필요한 <u><strong>행동</strong></u>을 생각하고, 행동을 수행할 <u><strong>객체</strong></u>를 선택한 후에, 행동을 결정하고 행동에 필요한 정보가 무엇인지를 고려하면서 그제서야 적절한 <u><strong>상태</strong></u>를 선택하게 되는 것이다.</p>\n<br/>\n<p>객체의 행동은 결국 객체가 협력에 참여하면서 완수해야 하는 <u><strong>책임</strong></u>이다. 따라서 어떤 책임이 필요한가를 결정하는 과정이 설계를 주도해야 한다. -> <code class=\"language-text\">책임-주도 설계</code>는 협력 안에서 객체의 행동을 생각하도록 도움으로써 응집도 높고 재사용 가능한 객체를 만들 수 있게 한다.</p>\n<h2 id=\"이상한-나라를-창조하라\" style=\"position:relative;\"><a href=\"#%EC%9D%B4%EC%83%81%ED%95%9C-%EB%82%98%EB%9D%BC%EB%A5%BC-%EC%B0%BD%EC%A1%B0%ED%95%98%EB%9D%BC\" aria-label=\"이상한 나라를 창조하라 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>이상한 나라를 창조하라</h2>\n<p>객체지향 세계는 현실을 모방한 것이 아니다. 현실을 참조할 수 있지만, 현실과 전혀 다른 새로운 세계를 창조한다. <u><strong>우리는 현실을 모방하는 게 아니고 이상한 나라를 창조하기만 하면 된다.</strong></u> 현실을 닮아야 한다는 어떤 제약도 없지만, 내가 창조한 객체의 특성을 상기시킬 수 있다면 현실 속의 객체의 이름을 이용해서 객체를 묘사할 수도 있다. 어쨌든 자유롭게 새로운 세계를 창조하자.</p>\n<div class=\"table-of-contents\">\n<ul>\n<li>\n<p><a href=\"#-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5%EC%9D%98-%EC%82%AC%EC%8B%A4%EA%B3%BC-%EC%98%A4%ED%95%B4--%EC%97%AD%ED%95%A0-%EC%B1%85%EC%9E%84-%ED%98%91%EB%A0%A5-%EA%B4%80%EC%A0%90%EC%97%90%EC%84%9C-%EB%B3%B8-%EA%B0%9D%EC%B2%B4%EC%A7%80%ED%96%A5\">📓 객체지향의 사실과 오해 | 역할, 책임, 협력 관점에서 본 객체지향</a></p>\n</li>\n<li>\n<p><a href=\"#-%EC%9D%B4%EC%83%81%ED%95%9C-%EB%82%98%EB%9D%BC%EC%9D%98-%EA%B0%9D%EC%B2%B4\">😼 이상한 나라의 객체</a></p>\n<ul>\n<li><a href=\"#%EA%B0%9D%EC%B2%B4\">객체</a></li>\n<li><a href=\"#-%ED%96%89%EB%8F%99%EC%9D%B4-%EC%83%81%ED%83%9C%EB%A5%BC-%EA%B2%B0%EC%A0%95%ED%95%9C%EB%8B%A4\">✨ 행동이 상태를 결정한다</a></li>\n<li><a href=\"#%EC%9D%B4%EC%83%81%ED%95%9C-%EB%82%98%EB%9D%BC%EB%A5%BC-%EC%B0%BD%EC%A1%B0%ED%95%98%EB%9D%BC\">이상한 나라를 창조하라</a></li>\n</ul>\n</li>\n</ul>\n</div>","frontmatter":{"date":"October 07, 2022","title":"02. 이상한 나라의 객체 |📓 객체지향의 사실과 오해","categories":"도서","author":"goldggyul","emoji":"🐇","imageEmoji":null},"fields":{"slug":"/book-object-real-002/"}},"site":{"siteMetadata":{"siteUrl":"https://goldggyul.github.io","comments":{"utterances":{"repo":"goldggyul/goldggyul.github.io"}}}}},"pageContext":{"slug":"/spring-core-basic-001/","nextSlug":"/book-object-real-001/","prevSlug":"/book-object-real-002/"}},"staticQueryHashes":["1956554647","2938748437","3350743975","3454833782"]}